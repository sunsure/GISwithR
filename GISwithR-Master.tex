% http://www.inside-r.org/packages/cran/RgoogleMaps/docs/GetMap


\documentclass[a4paper,12pt]{article}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{eurosym}
\usepackage{vmargin}
\usepackage{amsmath}
\usepackage{graphics}
\usepackage{epsfig}
\usepackage{subfigure}
\usepackage{fancyhdr}
%\usepackage{listings}
\usepackage{framed}
\usepackage{graphicx}

\setcounter{MaxMatrixCols}{10}
%TCIDATA{OutputFilter=LATEX.DLL}
%TCIDATA{Version=5.00.0.2570}
%TCIDATA{<META NAME="SaveForMode" CONTENT="1">}
%TCIDATA{LastRevised=Wednesday, February 23, 2011 13:24:34}
%TCIDATA{<META NAME="GraphicsSave" CONTENT="32">}
%TCIDATA{Language=American English}

\pagestyle{fancy}
\setmarginsrb{20mm}{0mm}{20mm}{25mm}{12mm}{11mm}{0mm}{11mm}
\lhead{Dublin \texttt{R}} \rhead{May 2013}
\chead{Spatial Data Analysis with \texttt{R}}
%\input{tcilatex}


% http://spatialanalysis.co.uk/2013/04/analysis-visualisation-spatial-data/
\begin{document}

\tableofcontents
\newpage
\section*{Revolution Analytics}
\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{./RevolutionAnalytics}
\hspace{8\baselineskip} {\Large Sponsors of Dublin \texttt{R}}
%\label{fig:RevolutionAnalytics}
\end{figure}




\subsection*{About Revolution Analytics}
Revolution Analytics is a statistical software company focused on developing "open-core" versions of the free and open source software R for enterprise, academic and analytics customers. 
\\
\\
\noindent Revolution Analytics was founded in 2007 as REvolution Computing providing support and services for R in a model similar to Red Hat's approach with Linux in the 1990s as well as bolt-on additions for parallel processing. 
\\
\\
\noindent Their core product, Revolution R, would be offered free to academic users and their commercial software would focus on big data, large scale multiprocessor (or "high performance") computing, and multi-core functionality.
\newpage
%-------------------------------------------------------------------------------------%
\begin{description}

\item[raster] Geographic data analysis and modeling.Reading, writing, manipulating, analyzing and modeling of gridded spatial data. The package implements basic and high-level functions and processing of very large files is supported.

\item[rts] rts: Raster time series analysis. This package aims to provide classes and methods for manipulating and processing of raster time series data (e.g. a time series of satellite images).

\item[gdistance] gdistance: distances and routes on geographical grids. Calculate distances and routes on geographic grids.

\item[rworldmap]  Mapping global data, vector and raster. Enables mapping of country level and gridded user datasets
\end{itemize}
%-------------------------------------------------------------------------------------%
%---------------------------------------------------- %
\section{Contour Plots}
\begin{figure}[h]
\centering
\includegraphics[width=0.7\linewidth]{./Contour1}
\caption{}
\label{fig:Contour1}
\end{figure}

\newpage
\section{Data Types}
The different types
of data models that we distinguish here include the following:
\begin{description}
\item[Point], a single point location, such as a GPS reading or a geocoded address
\item[Line], a set of ordered points, connected by straight line segments
\item[Polygon], an area, marked by one or more enclosing lines, possibly containing
holes
\item[Grid], a collection of points or rectangular cells, organised in a regular lattice
\end{description}
%--------------------------------------------------- %
\section{GIS and Spatial Data}
The \texttt{sp} package provides classes and methods for points, lines, polygons, and grids . 

Adopting a single set of classes for spatial data
offers a number of important advantages:
\begin{itemize}
\item[(i)] It is much easier to move data across spatial statistics packages. The
classes are either supported directly by the packages, reading and writing
data in the new spatial classes, or indirectly, for example by supplying
data conversion between the sp classes and the package?s classes in an
interface package. This last option requires one-to-many links between the
packages, which are easier to provide and maintain than many-to-many
links.
\item[(ii)] The new classes come with a well-tested set of methods (functions) for
plotting, printing, subsetting, and summarising spatial objects, or combining
(overlaying) spatial data types.
\item[(iii)] Packages with interfaces to geographical information systems (GIS), for
reading and writing GIS file formats, and for coordinate (re)projection
code support the new classes.
\item[(iv)] The new methods include Lattice plots, conditioning plots, plot methods
that combine points, lines, polygons, and grids with map elements (reference
grids, scale bars, north arrows), degree symbols (as in 52-N) in axis
labels, etc.
\end{itemize}

\section{KML}
Keyhole Markup Language (KML) is an XML notation for expressing geographic annotation and visualization within Internet-based, two-dimensional maps and three-dimensional Earth browsers. KML was developed for use with Google Earth, which was originally named Keyhole Earth Viewer. It was created by Keyhole, Inc, which was acquired by Google in 2004. 
KML became an international standard of the Open Geospatial Consortium in 2008.
%---------------------------------------------%
\section{Important Packages}


\documentclass[12pt]{article}
\usepackage{framed}
\usepackage{amsmath}
%opening
\title{GIS with \texttt{R}}
\author{Dublin \texttt{R}}

\begin{document}

\maketitle

\begin{abstract}
A series of eight short demonstrations of R's mapping and spatial statistics capability.
\end{abstract}
%----------------------------------------------- %
\newpage
\tableofcontents
\newpage
%----------------------------------------------- %
\section*{Overview of Workshop}
\begin{enumerate}
\item The \textit{\textbf{maproj}} package
\item The \textit{\textbf{ggmap}} package (David Kahle and Hadley Wickham )
\item 
\end{enumerate}

%----------------------------------------------- %
\newpage
\section{New Book}
Creating a geographical map using \textit{\textbf{ggplot2}}
\begin{framed}
\begin{verbatim}
library(maps)
states_map <-map_data("state")

ggplot(states_map, aes (x=long,y=lat,group=group)) +
 geom_polygon(fill="white",colour="black")


ggplot(states_map, aes (x=long,y=lat,group=group)) + 
geom_path() + coord_map(fill="mercator")

\end{verbatim}
\end{framed}

The \texttt{map$\_$data()} returns a data frame with the following columns:
\begin{itemize}
\item \texttt{long}
\item \texttt{lat}
\item \texttt{group}
\item order
\item region
\item subregion
\end{itemize}

Available Maps : 
world, nz,france,italy,usa, state ,county,
%----------------------------------------------- %
% Maps
%
\newpage
\section{Using \textit{map} package}
\textit{\textbf{maps:}}: Draw Geographical Maps

Display of maps. Projection code and larger maps are in separate packages (mapproj and mapdata).

%----------------------------------------------- %
% Maptools
%

\newpage
\section{Using \textit{maptools} package}
\textit{\textbf{maptools}}: Tools for reading and handling spatial objects (Roger Bivand)

\bigskip

\textit{Set of tools for manipulating and reading geographic data, in particular ESRI shapefiles; C code used from shapelib. It includes binary access to GSHHS shoreline files.}

\textit{The package also provides interface wrappers for exchanging spatial objects with packages such as PBSmapping, spatstat, maps, RArcInfo, Stata tmap, WinBUGS, Mondrian, and others.}
%----------------------------------------------- %
\newpage
% New Book Page 315
\section{Using \textit{mapdata} for making maps}
\
%----------------------------------------------- %
\newpage
\section{Cholorpleth Map}
% New Book Page 317
Maps coloured aoording to variable valued

\begin{framed}
\begin{verbatim}
crimes <- data.frame(state= tolower(rownames(USArrests)),USArrests)

library(maps)
states_map <- map_data("state")

crime_map= merge(state_map,crimes,by.x="region", by.y="state")
\end{verbatim}
\end{framed}

\subsection*{Diverging Colour Scale.}
%----------------------------------------------- %
% ggmap
% http://blog.revolutionanalytics.com/2012/07/making-beautiful-maps-in-r-with-ggmap.html
%----------------------------------------------- %

\newpage
\section{Using \textit{ggmap} for making maps}

%--------------------- %
\begin{framed}
\begin{verbatim}
library(ggmap)
geocode("Dublin Castle")
\end{verbatim}
\end{framed}
This yields the longtitude (EW) and the latitude (NS) for Dublin Castle.


\begin{verbatim}
> geocode("Dublin Castle")
...
Google Maps API Terms of Service : http://developers.google.com/maps/terms
        lon      lat
1 -6.266327 53.34387
\end{verbatim}

\textbf{Exercise:} Try it out for a few other \textit{\textbf{viable}} locations.
\begin{itemize}
\item Cork, Rosslare, Limerick, Westport, Sligo, Rockall, Belfast.
\item New York, Madrid, Rome, Moscow, Auckland, Tokyo
\end{itemize}
 
\subsection*{A Different Dublin Castle?}
The Dublin Castle Pub in Cambden Town London.
\begin{verbatim}
> geocode("Dublin Castle, Cambden")
....
Google Maps API Terms of Service : http://developers.google.com/maps/terms
         lon      lat
1 -0.1456995 51.53742 
\end{verbatim}

%--------------------- %
\newpage
\section{RColorBrewer}



Scale bar and North arrow on a ggplot2 map using R
Posté le 10 novembre 2013 par Ewen
After some research on the Internet, I gave up trying to find an R function to add a scale bar and a North arrow on a map, using ggplot().
So, I would like to present you what I have come up with.

The idea is really basic : we create two polygons for the scale bar, we add some text above, and we draw an arrow. That’s it. The only tricky thing here, is the way to obtain the coordinates of each element. An easy solution is to use the gcDestination function, from the maptools package.

From the user’s point of vue, there is only one function to use (scaleBar), and a few arguments to pass. However, this function has some dependencies.

First, let us load some packages:

?

library(maps)
library(maptools)
library(ggplot2)
library(grid)
Then, we need a function to get the scale bar coordinates:

?

#
# Result #
#--------#
# Return a list whose elements are :
#   - rectangle : a data.frame containing the coordinates to draw the first rectangle ;
#   - rectangle2 : a data.frame containing the coordinates to draw the second rectangle ;
#   - legend : a data.frame containing the coordinates of the legend texts, and the texts as well.
#
# Arguments : #
#-------------#
# lon, lat : longitude and latitude of the bottom left point of the first rectangle to draw ;
# distanceLon : length of each rectangle ;
# distanceLat : width of each rectangle ;
# distanceLegend : distance between rectangles and legend texts ;
# dist.units : units of distance "km" (kilometers) (default), "nm" (nautical miles), "mi" (statute miles).
createScaleBar <- function(lon,lat,distanceLon,distanceLat,distanceLegend, dist.units = "km"){
    # First rectangle
    bottomRight <- gcDestination(lon = lon, lat = lat, bearing = 90, dist = distanceLon, dist.units = dist.units, model = "WGS84")
     
    topLeft <- gcDestination(lon = lon, lat = lat, bearing = 0, dist = distanceLat, dist.units = dist.units, model = "WGS84")
    rectangle <- cbind(lon=c(lon, lon, bottomRight[1,"long"], bottomRight[1,"long"], lon),
    lat = c(lat, topLeft[1,"lat"], topLeft[1,"lat"],lat, lat))
    rectangle <- data.frame(rectangle, stringsAsFactors = FALSE)
     
    # Second rectangle t right of the first rectangle
    bottomRight2 <- gcDestination(lon = lon, lat = lat, bearing = 90, dist = distanceLon*2, dist.units = dist.units, model = "WGS84")
    rectangle2 <- cbind(lon = c(bottomRight[1,"long"], bottomRight[1,"long"], bottomRight2[1,"long"], bottomRight2[1,"long"], bottomRight[1,"long"]),
    lat=c(lat, topLeft[1,"lat"], topLeft[1,"lat"], lat, lat))
    rectangle2 <- data.frame(rectangle2, stringsAsFactors = FALSE)
     
    # Now let's deal with the text
    onTop <- gcDestination(lon = lon, lat = lat, bearing = 0, dist = distanceLegend, dist.units = dist.units, model = "WGS84")
    onTop2 <- onTop3 <- onTop
    onTop2[1,"long"] <- bottomRight[1,"long"]
    onTop3[1,"long"] <- bottomRight2[1,"long"]
     
    legend <- rbind(onTop, onTop2, onTop3)
    legend <- data.frame(cbind(legend, text = c(0, distanceLon, distanceLon*2)), stringsAsFactors = FALSE, row.names = NULL)
    return(list(rectangle = rectangle, rectangle2 = rectangle2, legend = legend))
}
We also need a function to obtain the coordinates of the North arrow:


#
# Result #
#--------#
# Returns a list containing :
#   - res : coordinates to draw an arrow ;
#   - coordinates of the middle of the arrow (where the "N" will be plotted).
#
# Arguments : #
#-------------#
# scaleBar : result of createScaleBar() ;
# length : desired length of the arrow ;
# distance : distance between legend rectangles and the bottom of the arrow ;
# dist.units : units of distance "km" (kilometers) (default), "nm" (nautical miles), "mi" (statute miles).
createOrientationArrow <- function(scaleBar, length, distance = 1, dist.units = "km"){
    lon <- scaleBar$rectangle2[1,1]
    lat <- scaleBar$rectangle2[1,2]
     
    # Bottom point of the arrow
    begPoint <- gcDestination(lon = lon, lat = lat, bearing = 0, dist = distance, dist.units = dist.units, model = "WGS84")
    lon <- begPoint[1,"long"]
    lat <- begPoint[1,"lat"]
     
    # Let us create the endpoint
    onTop <- gcDestination(lon = lon, lat = lat, bearing = 0, dist = length, dist.units = dist.units, model = "WGS84")
     
    leftArrow <- gcDestination(lon = onTop[1,"long"], lat = onTop[1,"lat"], bearing = 225, dist = length/5, dist.units = dist.units, model = "WGS84")
     
    rightArrow <- gcDestination(lon = onTop[1,"long"], lat = onTop[1,"lat"], bearing = 135, dist = length/5, dist.units = dist.units, model = "WGS84")
     
    res <- rbind(
            cbind(x = lon, y = lat, xend = onTop[1,"long"], yend = onTop[1,"lat"]),
            cbind(x = leftArrow[1,"long"], y = leftArrow[1,"lat"], xend = onTop[1,"long"], yend = onTop[1,"lat"]),
            cbind(x = rightArrow[1,"long"], y = rightArrow[1,"lat"], xend = onTop[1,"long"], yend = onTop[1,"lat"]))
     
    res <- as.data.frame(res, stringsAsFactors = FALSE)
     
    # Coordinates from which "N" will be plotted
    coordsN <- cbind(x = lon, y = (lat + onTop[1,"lat"])/2)
     
    return(list(res = res, coordsN = coordsN))
}
The last function enables the user to draw the elements:


#
# Result #
#--------#
# This function enables to draw a scale bar on a ggplot object, and optionally an orientation arrow #
# Arguments : #
#-------------#
# lon, lat : longitude and latitude of the bottom left point of the first rectangle to draw ;
# distanceLon : length of each rectangle ;
# distanceLat : width of each rectangle ;
# distanceLegend : distance between rectangles and legend texts ;
# dist.units : units of distance "km" (kilometers) (by default), "nm" (nautical miles), "mi" (statute miles) ;
# rec.fill, rec2.fill : filling colour of the rectangles (default to white, and black, resp.);
# rec.colour, rec2.colour : colour of the rectangles (default to black for both);
# legend.colour : legend colour (default to black);
# legend.size : legend size (default to 3);
# orientation : (boolean) if TRUE (default), adds an orientation arrow to the plot ;
# arrow.length : length of the arrow (default to 500 km) ;
# arrow.distance : distance between the scale bar and the bottom of the arrow (default to 300 km) ;
# arrow.North.size : size of the "N" letter (default to 6).
scaleBar <- function(lon, lat, distanceLon, distanceLat, distanceLegend, dist.unit = "km", rec.fill = "white", rec.colour = "black", rec2.fill = "black", rec2.colour = "black", legend.colour = "black", legend.size = 3, orientation = TRUE, arrow.length = 500, arrow.distance = 300, arrow.North.size = 6){
    laScaleBar <- createScaleBar(lon = lon, lat = lat, distanceLon = distanceLon, distanceLat = distanceLat, distanceLegend = distanceLegend, dist.unit = dist.unit)
    # First rectangle
    rectangle1 <- geom_polygon(data = laScaleBar$rectangle, aes(x = lon, y = lat), fill = rec.fill, colour = rec.colour)
     
    # Second rectangle
    rectangle2 <- geom_polygon(data = laScaleBar$rectangle2, aes(x = lon, y = lat), fill = rec2.fill, colour = rec2.colour)
     
    # Legend
    scaleBarLegend <- annotate("text", label = paste(laScaleBar$legend[,"text"], dist.unit, sep=""), x = laScaleBar$legend[,"long"], y = laScaleBar$legend[,"lat"], size = legend.size, colour = legend.colour)
     
    res <- list(rectangle1, rectangle2, scaleBarLegend)
     
    if(orientation){# Add an arrow pointing North
        coordsArrow <- createOrientationArrow(scaleBar = laScaleBar, length = arrow.length, distance = arrow.distance, dist.unit = dist.unit)
        arrow <- list(geom_segment(data = coordsArrow$res, aes(x = x, y = y, xend = xend, yend = yend)), annotate("text", label = "N", x = coordsArrow$coordsN[1,"x"], y = coordsArrow$coordsN[1,"y"], size = arrow.North.size, colour = "black"))
        res <- c(res, arrow)
    }
    return(res)
}
Now, let’s play with this!

Let us draw the US map:

?
1
2
3
# United States map
usa.map <- map_data("state")
P <- ggplot() + geom_polygon(data = usa.map, aes(x = long, y = lat, group = group)) + coord_map()
If we want to add the scale bar only:

?
1
P + scaleBar(lon = -130, lat = 26, distanceLon = 500, distanceLat = 100, distanceLegend = 200, dist.unit = "km", orientation = FALSE)

US map using ggplot2 and scaleBar, without North arrow

Or if we want the scale bar and the North arrow:
?
1
P <- P + scaleBar(lon = -130, lat = 26, distanceLon = 500, distanceLat = 100, distanceLegend = 200, dist.unit = "km")
To make it look more like a map:

?

P + theme(panel.grid.minor = element_line(colour = NA), panel.grid.minor = element_line(colour = NA),
    panel.background = element_rect(fill = NA, colour = NA), axis.text.x = element_blank(),
    axis.text.y = element_blank(), axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank(), axis.title = element_blank(),
    rect = element_blank(),
    plot.margin = unit(0 * c(-1.5, -1.5, -1.5, -1.5), "lines"))

US map using ggplot2 and scaleBar
Another example, with France:

?

france.map <- map_data("france")
P.fr <- ggplot() + geom_polygon(data = france.map, aes(x = long, y = lat, group = group)) + coord_map()
 
# Let us add the scale bar
P.fr <- P.fr + scaleBar(lon = -5, lat = 42.5, distanceLon = 100, distanceLat = 20, distanceLegend = 40, dist.unit = "km", arrow.length = 100, arrow.distance = 60, arrow.North.size = 6)
 
# Modifying the theme a bit
P.fr + theme(panel.grid.minor = element_line(colour = NA), panel.grid.minor = element_line(colour = NA),
    panel.background = element_rect(fill = NA, colour = NA), axis.text.x = element_blank(),
    axis.text.y = element_blank(), axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank(), axis.title = element_blank(),
    rect = element_blank(),
    plot.margin = unit(0 * c(-1.5, -1.5, -1.5, -1.5), "lines"))

France map using ggplot2 and scaleBar
Posté dans Cartes, Informatique, Non classé	 | Tags : ggplot2, legend, Map, north arrow, R, scale bar	 |
%--------------------- %

\newpage
\section{Projected Maps}
%
% http://geography.uoregon.edu/GeogR/examples/maps_examples02.htm
% http://geography.uoregon.edu/GeogR/examples/maps_examples01.htm
The \texttt{sp} class and \textit{\textbf{maptools}} package provide a mechanism for doing projected maps.  (Note that the projection parameters used in the example here are not really appropriate for the area being plotted, but were chosen to make the fact that the data are projected evident.)

First, load the \textit{\textbf{rgdal}} package
%-------------- %
\begin{verbatim}
library(rgdal)
\end{verbatim}
%-------------- %
This example plots a projected map of Oregon climate station data where the data are contained in the  in the orstations shapefile.  The first block of code does some set up (class intervals and colors, etc.)
\begin{framed}
\begin{verbatim}
# equal-frequency class intervals -- spplot & projected
plotvar <- orstations.shp@data$tann # gets data from shapefile .dbf
nclr <- 8
plotclr <- brewer.pal(nclr,"PuOr")
plotclr <- plotclr[nclr:1] # reorder colours
class <- classIntervals(plotvar, nclr, style="quantile")
colcode <- findColours(class, plotclr)
basemap <- list("sp.lines", orotl.shp, fill=NA)
\end{verbatim}
\end{framed}


\end{document}
\end{document}

